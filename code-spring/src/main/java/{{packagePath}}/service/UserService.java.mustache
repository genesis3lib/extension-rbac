package {{javaPackageFull}}.service;

import {{javaPackageFull}}.jpa.entity.UserEntity;
import {{javaPackageFull}}.jpa.repository.UserRepository;
import {{javaPackageFull}}.jpa.enumtype.UserRole;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.beans.factory.annotation.Value;

import java.util.List;
import java.util.Optional;
import java.util.Set;


@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class UserService {

    private final UserRepository userRepository;

    @Value("${app.users.root:}")
    private String rootUser;

    @Value("${app.users.admins:}")
    private Set<String> adminUsers;

    public Optional<UserEntity> findByEmail(String email) {
        return userRepository.findByEmailAndDeletedFalse(email);
    }

    public Optional<UserEntity> findByExternalAuth(String provider, String externalId) {
        return userRepository.findByExternalAuthProviderAndExternalAuthIdAndDeletedFalse(provider, externalId);
    }

    public Optional<UserEntity> findByExternalAuthId(String externalId) {
        return userRepository.findByExternalAuthIdAndDeletedFalse(externalId);
    }

    public Optional<UserEntity> findBySlug(String slug) {
        return userRepository.findBySlugAndDeletedFalse(slug);
    }

    /**
     * Creates or updates a user from external authentication provider.
     *
     * @param tenantId Tenant ID (optional, can be null for single-tenant apps)
     * @param email User's email address
     * @param externalProvider External auth provider (e.g., "auth0", "google-oauth2")
     * @param externalId External auth ID (e.g., "auth0|123456")
     * @param firstName User's first name
     * @param lastName User's last name
     * @param picture User's profile picture URL
     * @param isEmailVerified Whether the user's email is verified
     * @param createUserOnFirstLogin Whether to create user if not exists
     * @param updateUserOnEachLogin Whether to update user profile on each login
     * @return The created or updated user entity
     */
    public UserEntity createOrUpdateUser(String tenantId, String email, String externalProvider, String externalId,
                                        String firstName, String lastName, String picture,
                                        boolean isEmailVerified, boolean createUserOnFirstLogin,
                                        boolean updateUserOnEachLogin) {
        Optional<UserEntity> existingUser = findByExternalAuth(externalProvider, externalId);

        UserEntity user;
        if (existingUser.isPresent()) {
            user = existingUser.get();
            // Only update if configured to do so
            if (!updateUserOnEachLogin) {
                log.debug("User exists and updateUserOnEachLogin=false, skipping update for: {}", email);
                return user;
            }
            log.debug("Updating existing user: {}", email);
        } else {
            // Only create if configured to do so
            if (!createUserOnFirstLogin) {
                log.warn("User not found and createUserOnFirstLogin=false, rejecting: {}", email);
                throw new IllegalStateException("User not found and automatic user creation is disabled");
            }

            List<UserRole> roles = new java.util.ArrayList<>(List.of(UserRole.USER));
            if (StringUtils.equalsIgnoreCase(rootUser, email)) {
                log.warn("Creating root user: {}", email);
                roles = new java.util.ArrayList<>(List.of(UserRole.ROOT, UserRole.ADMIN, UserRole.USER));
            } else if (adminUsers != null && adminUsers.stream().anyMatch(i -> StringUtils.equalsIgnoreCase(i, email))) {
                log.warn("Creating admin user: {}", email);
                roles = new java.util.ArrayList<>(List.of(UserRole.ADMIN, UserRole.USER));
            }
            user = UserEntity.builder()
                    .tenantId(tenantId)
                    .username(email)
                    .email(email)
                    .externalAuthProvider(externalProvider)
                    .externalAuthId(externalId)
                    .roles(roles)
                    .enabled(true)
                    .emailVerified(isEmailVerified)
                    .build();
            log.info("Creating new user: {}", email);
        }

        // Update user information
        user.setFirstName(firstName);
        user.setLastName(lastName);
        user.setPicture(picture);
        user.setEmail(email);
        user.setEmailVerified(isEmailVerified);

        UserEntity savedUser = userRepository.save(user);
        userRepository.flush(); // Force immediate write to database
        return savedUser;
    }

    /**
     * Simple overload for backwards compatibility - creates user on first login, no updates.
     */
    public UserEntity createOrUpdateUser(String tenantId, String email, String externalProvider, String externalId,
                                        String firstName, String lastName, String picture) {
        return createOrUpdateUser(tenantId, email, externalProvider, externalId,
                firstName, lastName, picture, true, true, false);
    }

    public List<UserEntity> findByTenant(String tenantId) {
        return userRepository.findByTenantIdAndDeletedFalse(tenantId);
    }

    public List<UserEntity> findByRole(UserRole role) {
        return userRepository.findByRoleAndDeletedFalse(role.getValue());
    }

    public void softDeleteUser(Long userId, String reason) {
        userRepository.findById(userId).ifPresent(user -> {
            user.setDeleted(true);
            user.setDeleteReason(reason);
            userRepository.save(user);
            log.info("Soft deleted user: {} with reason: {}", user.getEmail(), reason);
        });
    }

    public UserEntity addRole(Long userId, UserRole role) {
        return userRepository.findById(userId).map(user -> {
            if (!user.getRoles().contains(role)) {
                user.getRoles().add(role);
                return userRepository.save(user);
            }
            return user;
        }).orElseThrow(() -> new RuntimeException("User not found: " + userId));
    }

    public UserEntity removeRole(Long userId, UserRole role) {
        return userRepository.findById(userId).map(user -> {
            user.getRoles().remove(role);
            return userRepository.save(user);
        }).orElseThrow(() -> new RuntimeException("User not found: " + userId));
    }
}
